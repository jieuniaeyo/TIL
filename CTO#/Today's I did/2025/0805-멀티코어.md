# Node.js 멀티코어 테스트

## 대전제
Node.js 환경에서는 `worker_threads` 모듈을 사용하여 CPU 코어를 여러 개 활용할 수 있음.

---

## 테스트 시나리오

**테스트 내용**
1. main에서 2분간 CPU를 사용할 때 API 요청이 갈까?
2. 한 엔드포인트에서 for 루프로 CPU를 점유하면 다른 API 요청이 갈까?
3. 스레드를 하나 더 사용해 (태스크 분배) for 루프를 돌게 할 때 API 요청이 갈까?

---

### 1번 상황

```tsx
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
const { Worker } = require('worker_threads');

const src = './forloop.js';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
  for (let i = 0; i <= 100000000000; i++) {
  }
}
bootstrap();
````

**결과**

* API 요청 시
  무한 대기 발생
* 메인 스레드가 CPU를 100% 점유하여 이벤트 루프가 돌지 못하므로, 서버가 멈춘 것처럼 보임

---

### 2번 상황

**Controller**

```tsx
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello() {
    return this.appService.getHello();
  }

  @Get('single_core')
  async handleSingleCoreHeavyRequet() {
    const result = await this.appService.runSingleCoreHeavyRequest();
    return { result };
  }
}
```

**Service**

```tsx
import { Injectable } from '@nestjs/common';
import * as path from "node:path";
const { Worker } = require('worker_threads');

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
  
  runSingleCoreHeavyRequest(): Promise<string> {
    return new Promise((resolve, reject) => {
      let count = 0;
      for (let i = 0; i < 1000000000000; i++) {
        count++;
      }

      return resolve('for 루프 끝!');
    });
  }
}
```

**결과**

* 해당 API 요청 시 서버가 멈춘 것처럼 보이고, 다른 요청도 대기 상태로 진입
* 이유: 메인 스레드가 블로킹 연산(for loop)을 실행하여 이벤트 루프가 요청 처리 불가

---

### 3번 상황

**Controller**

```tsx
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello() {
    return this.appService.getHello();
  }

  @Get('heavy')
  async handleHeavyRequest() {
    const result = await this.appService.runHeavyWorker();
    return { result };
  }
}
```

**Service**

```tsx
import { Injectable } from '@nestjs/common';
import * as path from "node:path";
const { Worker } = require('worker_threads');

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }

  runHeavyWorker(): Promise<string> {
    return new Promise((resolve, reject) => {
      const workerPath = path.join(__dirname, 'worker', 'forloop.js');
      const worker = new Worker(workerPath);

      worker.on('message', (message) => resolve(message));
      worker.on('error', reject);
      worker.on('exit', (code) => {
        if (code !== 0) reject(new Error(`에러`));
      });
    });
  }
}
```

**Worker**

```tsx
const { parentPort } = require('worker_threads');

let count = 0;
for (let i = 0; i < 1000000000000; i++) {
    count++;
}

parentPort.postMessage(`for 루프 끝! ${count}`);
```

**결과**

* 각 요청에 대한 응답이 정상적으로 반환됨
* 이유: CPU 집약적인 작업을 메인 스레드 대신 워커 스레드에서 처리


## 문제 상황

* 기존에는 멀티코어로 요청 처리가 가능했으나, 클라이언트에서 요청 취소(`cancel`)를 하더라도 이미 실행 중인 연산은 즉시 중단되지 않음
* 즉, 워커 또는 메인 스레드에서 시작한 연산은 명시적으로 종료시키지 않으면 계속 진행됨
* 실행 중인 Node.js 프로세스 확인 방법:

```bash
ps aux | grep node
```


## 메인 스레드와 CPU 점유

* 메인 스레드 = 이벤트 루프 처리 담당
* CPU 집약적인 작업을 워커에 8개 모두 분배하면, 8코어 환경에서는 CPU가 전부 워커에 점유됨
* 이 경우 메인 스레드는 CPU 자원을 거의 쓰지 못해 API 요청 응답이 지연됨

## 결론

* Node.js는 싱글 스레드 기반이지만, 내부적으로 `libuv`를 통해 `worker_threads`로 병렬 처리 가능
* CPU 집약 작업은 이벤트 루프가 아닌 워커 스레드에서 처리해야 함
* for-loop 같이 블로킹 연산은 반드시 워커로 분리하여 메인 스레드를 비워둬야 함
* 대부분의 백엔드 프레임워크에는 요청 대기 큐가 존재하므로, 메인 스레드가 당장 처리하지 못해도 큐에 쌓였다가 타임아웃 전 처리 가능
* 단, 워커 점유율이 높으면 요청 처리 속도가 현저히 떨어질 수 있음

