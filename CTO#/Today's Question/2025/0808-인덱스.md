# Notification 테이블과 인덱스 관리

### 1. Notification 테이블 특성
- Notification 테이블은 **INSERT와 SELECT가 모두 많은 테이블**
- 즉, 데이터 조회와 삽입이 모두 빈번하게 발생함

---

### 2. 인덱스 장단점

**장점 (주로 SELECT 시점)**
- 조회 성능 향상
- 조건 검색이 빨라지고, 특정 데이터를 찾는 시간이 단축됨

**단점 (주로 INSERT, UPDATE, DELETE 시점)**
- 데이터 변경 시 인덱스도 함께 관리해야 함
- **신규 데이터 생성 시 인덱스 갱신** 필요
    - 인덱스 노드를 재정렬하거나 split 필요
- 인덱스가 많으면 쓰기 부하가 기하급수적으로 증가

---

### 3. 인덱스를 유지 vs 유지하지 않음

**인덱스를 유지한다면**
- INSERT가 일어날 때마다 인덱스에 새로운 항목을 삽입
- 쓰기 시 오버헤드 존재 (노드 재정렬, split 등)
- 하지만 SELECT 성능 향상

**인덱스를 유지하지 않는다면**
- INSERT, UPDATE, DELETE 시 쓰기 부하 적음
- SELECT 시 데이터 전체를 조회 → 속도 저하
- 특정 조건 자주 조회 시 병목 발생

---

### 4. 비용 트레이드오프
- **쓰기 오버헤드** vs **조회 속도**

  → 실제 사용 패턴 분석 필요
  
  예: 16시간 45분 동안 들어온 데이터 3,858개 → 인덱스를 3,858번 업데이트

  조회 빈도가 삽입보다 높으면, **조회 성능 최적화가 우선**

  → 20만 개 정도 데이터라면 인덱스 갱신 비용은 크지 않음

  → n억 개 이상의 대규모 데이터라면 별도 전략 필요

---

### 5. 대용량 테이블 관리 전략

**1) 백업 + 재삽입 방식**
- 특정 기간 데이터를 백업
- 테이블을 정리한 후 다시 데이터 삽입
- 중소규모 데이터에서 활용 가능

**2) 파티셔닝 (Partitioning)**
- 테이블을 **범위, 해시, 리스트 등 기준으로 분할**
- 각 파티션별 인덱스 관리 가능 → INSERT/SELECT 병목 완화
- 예: 날짜별 파티션 → 최신 데이터 조회 시 빠른 검색 가능

**3) 샤딩 (Sharding)**
- **데이터를 여러 서버에 분산 저장**
- 하나의 서버가 모든 데이터를 처리하지 않음 → 쓰기/조회 병목 완화
- 주로 대규모 트래픽/데이터에서 사용

---

### 6. 결론
- Notification 테이블처럼 조회가 삽입보다 잦은 경우, **인덱스 유지 → 조회 성능 향상** 선택
- 대용량 데이터(n억 건 이상)에서는 **파티셔닝, 샤딩** 등 구조적 설계 필요
- 데이터 패턴에 따라 백업 + 재삽입 같은 임시 전략도 활용 가능

# MySQL 인덱스와 옵티마이저 동작 정리

### 1. 쿼리 예시
```sql
SELECT a, b, c
FROM ABC
WHERE a = :a AND b = :b AND c = :c;
````

* **경우 1:** 복합 인덱스 `(a, b, c)`
* **경우 2:** 단일 인덱스 `(a)`, `(b)`, `(c)` 각각 존재

### 질문

* 여러 개 단일 인덱스를 동시에 사용할 수 있을까?
* 경우 2에서 단일 인덱스 3개를 모두 적용하면 효율적일까?
* 옵티마이저가 자동으로 중첩(Index Merge)하는가?

---

### 2. Index Merge

* MySQL 옵티마이저는 **Index Merge**를 통해 한 테이블의 여러 단일 인덱스를 병합 가능
* 병합 방식: 교집합(INTERSECT), 합집합(UNION), 병합(MERGE)
* 단, 옵티마이저가 **비용 계산 후 효율적인 경우만 적용**
* 대부분의 경우 **복합 인덱스보다 비용이 큼 → 잘 사용하지 않음**

**복합 인덱스보다 비용이 큰 이유**

* 각 단일 인덱스에서 **rowId(PK) 목록**을 읽어 교집합/병합 → 오버헤드 발생
* 테이블(PK)로 **랜덤 룩업** 빈도 증가 → I/O 부담
* `ORDER BY`/`GROUP BY` 최적화 및 **커버링 인덱스 가능성** 저하

---

### 3. 복합 인덱스와 단일 인덱스가 동시에 존재할 경우

* 예: `(a, b, c)` + `(a)`, `(b)`, `(c)` 존재
* 옵티마이저는 **Index Merge를 고려**하지만,
  복합 인덱스가 비용 효율적이라면 **복합 인덱스를 선택**
* 즉, 실행 계획은 **비용 기반 최적화**로 결정됨

---

### 4. 결론

* 단일 인덱스만 있어도 MySQL은 **Index Merge**를 일부 활용 가능
* 대부분의 경우 **복합 인덱스가 더 효율적**
* 복합 인덱스 + 단일 인덱스 동시 존재 시, **복합 인덱스 우선 사용**
* 따라서 인덱스 설계 시 **쿼리 조건 패턴에 맞는 복합 인덱스 설계가 중요**
