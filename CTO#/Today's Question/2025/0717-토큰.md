## A. 리프레스 토큰의 갱신 주기와 액세스 토큰의 재발급은 어떻게 처리하는 게 맞을까?

### 근거
<details>
  <summary>코드</summary>

```typescript
async createPost(
  createPostDto: CreatePostDto,
  accessToken: string,
  refreshToken: string,
  res: Response,
) {
  try {
    const payload: JwtPayloadInterface = await this.jwtService.verifyAsync(
      accessToken,
      {
        secret: this.configService.get<string>('ACCESS_TOKEN_SECRET'),
      },
    );

    const user = await this.userRepository.findOne({
      where: { user_id: payload.sub },
    });

    if (!user) {
      throw new NotFoundException('사용자를 찾을 수 없습니다.');
    }

    const newPost = this.postRepository.create({
      ...createPostDto,
      user,
    });

    const post = await this.postRepository.save(newPost);

    return PostResponseDto.builder(post.id);
  } catch (err) {
    const newAccessToken = await this.userService.refreshAccessToken(
      refreshToken,
      res,
    );

    return await this.createPost(
      createPostDto,
      newAccessToken,
      refreshToken,
      res,
    );
  }
}
```
</details>

### 이유
- 기존 로직은 매 로그인 시 리프레스 토큰 갱신
- 보통 리프레시 토큰의 주기는 1주~1개월인데 매 로그인마다 갱신 불필요한 갱신 같음
- 매 로그인마다 리프레시 토큰을 갱신하는 것은 비효율적이지 않을까?
- 기존 로직에서는 액세스 토큰 만료시 재귀적으로 처리
- 간혹가다 무한루프에 걸리는 경우 존재
- 액세스 토큰을 재발급 받는 다른 방식은 없을까?

---

## A. accessToken 만료 → 클라이언트가 refresh → 재요청이 일반적인 프로세스이다

### 프로세스

**액세스 토큰 만료 프로세스**
1. 클라이언트 요청
2. AccessToken 만료로 인한 에러
3. 클라이언트에서 Refresh Token을 통한 AccessToken 재발급
4. RefreshToken도 만료 및 로그인 페이지로 리다이렉팅
5. 로그인 후 AccessToken RefreshToken 재발급

**액세스 토큰 유효 프로세스**
1. 클라이언트 요청
2. AccessToken 만료로 인한 에러
3. 클라이언트에서 RefreshToken을 통한 AccessToken 재발급
4. RefreshToken 유효함
5. AccessToken 재발급
6. 인증이 필요한 API 호출 및 성공

### 결론
- 재귀로 처리하는 것보다는 클라이언트에서 액세스 토큰 인증 실패시 리프레스 토큰으로 갱신하는 API 호출하는 것이 일반적
