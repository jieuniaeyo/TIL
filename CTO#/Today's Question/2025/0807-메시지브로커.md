## Q. 소켓으로도 실시간 메시지 송수신은 가능한데, Redis 같은 메시지 브로커를 추가로 쓰는 이유는 무엇일까?
언제 소켓을 쓰고, 언제 브로커를 도입해야 할까?

---

## A.

### 1. 소켓(WebSocket)의 특징과 한계
소켓은 **양방향 실시간 통신**이 가능해 빠른 데이터 교환에 유리하지만, 메시지 처리/보관/분산 구조에서 한계가 있다

- **메시지 유실 위험**  
  연결이 끊기면 해당 시점의 메시지가 사라질 수 있음 (별도 저장/재전송 로직 필요)
- **브로드캐스트 / 멀티캐스트 한계**  
  같은 서버에 연결된 클라이언트끼리만 쉽게 가능, 서버 여러 대로 확장 시 복잡해짐
- **확장성 한계**  
  다중 서버 환경에서 세션 동기화를 직접 구현해야 함 (Sticky Session, Redis pub/sub 등을 추가적으로 써야 함)
- **고급 메시징 기능 부재**  
  우선순위 큐, 지연 전송, 재시도, Dead Letter Queue 같은 기능은 기본 제공되지 않음

---

### 2. 메시지 브로커(Redis, Kafka 등)를 사용하는 이유
메시지 브로커는 **메시지의 안정성·확장성·분산 처리**를 목적으로 설계됨

- **비동기 메시지 처리**  
  발신자와 수신자가 동시에 연결되어 있을 필요 없음 (큐에 저장 후 나중에 소비 가능)
- **브로드캐스트 / 멀티캐스트 지원**  
  구독 기반(pub/sub) 구조로 여러 소비자에게 쉽게 메시지 전송 가능
- **확장성**  
  서버 간 메시지 공유·동기화가 쉬워지고, 분산 서버 구조에 적합
- **내결함성 & 신뢰성**  
  Kafka 등은 디스크에 메시지를 저장하여 장애 후에도 복구 가능
- **고급 기능 제공**  
  큐잉, 지연 메시지, 재시도, 메시지 순서 보장, Dead Letter Queue 등 지원

---

### 3. 언제 소켓을 쓰는 게 좋은가?
- **양방향 실시간 통신**이 필요할 때
- **클라이언트가 실시간 반응**을 기대하는 UX일 때  
  예: 채팅, 게임, 주식 시세, 실시간 알림
- **서버 → 클라이언트 푸시**가 중요한 경우
- **낮은 지연시간**이 중요한 경우  
  (WebSocket은 TCP 기반으로 HTTP보다 헤더 오버헤드가 낮음)


  ![OSI 7Layers Packet Size](/image/pEAUt.png)

---

### 4. 정리
| 구분 | 소켓(WebSocket) | 메시지 브로커(Redis/Kafka 등) |
|------|----------------|------------------------------|
| **목적** | 실시간 양방향 데이터 송수신 | 안정적·확장 가능한 메시지 처리 |
| **데이터 보관** | 기본적으로 없음 | 보관 가능(지속성) |
| **확장성** | 단일 서버에 강점, 분산 어려움 | 분산·확장에 강점 |
| **브로드캐스트** | 제한적(같은 서버 내) | 구독 기반으로 손쉽게 가능 |
| **추가 기능** | 별도 구현 필요 | 큐잉, 재시도, 지연 전송 등 기본 제공 |

---
### **결론**
- **소켓만**: 단일 서버, 연결 유지가 중요한 **실시간 서비스**
- **메시지 브로커 추가**: 서버 확장, 안정성·신뢰성 보장, 메시지 처리 고도화가 필요한 경우


