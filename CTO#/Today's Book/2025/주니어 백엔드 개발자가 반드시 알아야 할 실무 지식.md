# \[처리량과 응답시간\] 커넥션풀, 캐싱

## 응답 시간

`[서버 연결 → 서버로 요청 전송 → /서버 실행/ → 클라이언트로 요청 전송]`
다음 과정을 거치는데 소요된 시간

-   Time To First Byte 응답의 첫 번째 바이트 도착까지 걸린 시간 (ms)
-   Time To Last Byte 응답의 마지막 바이트 도착까지 걸린 시간 (ms)

응답 시간과 사용자의 만족도의 상관관계

응답 시간을 줄인다고 만족도 반드시 증가 X, 하지만 응답 시간이 늘어나면
만족도는 확실히 감소

### 응답 시간에 영향을 주는 요인

-   로직 수행
-   DB 연동
-   외부 API 연동
-   응답 데이터 생성

→ 실제로 API 연동과 DB 연동이 대부분의 응답 시간을 차지

## 처리량 (Transaction Per Second)

단위당 시간 시스템이 처리하는 작업량

\*\* 이때 처리에 초점 즉, 0초에 시작되어 3초에 끝나는 작업이 있다면
3초의 처리량으로 카운트

서버가 처리할 수 있는 TPS를 초과한다면 서버는 초과된 요청을 나중에 처리

→ 이로 인해 초과된 요청을 보낸 사용자는 앞선 요청이 처리될 때까지
대기해야함 = 응답 시간 증가

**해결방법**

-   서버가 처리할 수 있는 요청 수 자체를 늘리기
-   처리 시간 자체를 줄이기

TPS를 늘리기 위해 먼저 해야 할 작업은 병목 지점 찾기

### 수직 확장

서버의 자원(CPU, 메모리, 디스크 등)을 증가시키는 방식

→ 즉각적인 효과를 얻을 수 있지만, 트래픽이 증가하면 결국 성능 문제가
다시 발생

서버가 다운되지 않도록 임시로 유지하면서, 그 시간 동안 근본적인 해결
방안을 찾는 용도로 활용

### 수평 확장

서버의 개수를 늘리는 방식

→ DB에 병목이 있다면 수평 확장 시 오히려 DB 부하가 증가할 수 있음

따라서, 병목 지점을 정확히 파악하는 것이 중요

외부 API나 DB 성능이 문제라면 수평 확장 시 각 요소에 더 많은 트래픽이
집중되어 TPS 향상 효과가 없음

## DB 커넥션 풀

DB 사용 시

1.  DB 연결
2.  쿼리 실행
3.  사용이 끝날 시 DB 연결 종료

보통 DB 연결 시 및 종료에 0.5초 \~ 1초의 시간 소요

만약 10ms의 쿼리를 실행하고 DB 연결 및 종료에 50ms가 소요된다면 전체
시간의 80%가 소요

### 커넥션 풀

커넥션들을 미리 생성해 보관 → DB 사용 시 커넥션을 가져와 사용하고 다시
풀에 반환 (재사용)

**주요 설정**

-   커넥션 풀 크기
-   커넥션 대기 시간
-   커넥션 유지 시간

### 커넥션 풀 크기

커넥션 풀에 미리 생성해둘 커넥션 개수 설정

-   최소 커넥션 수 (Minimum Pool Size): 풀에 항상 유지할 최소 커넥션
    개수
-   최대 커넥션 수 (Maximum Pool Size): 풀에서 생성할 수 있는 최대
    커넥션 개수

```{=html}
<!-- -->
```
    if) 커넥션 풀 크기 → 5
            쿼리 실행 → 0.1
    →   1초에 50개의 요청 처리 가능

    if) 커넥션 풀 크기 → 5
            쿼리 실행 → 0.5
    →   1초에 10개의 요청 처리 가능 

따라서 쿼리 실행에 걸리는 시간에 따라 적절한 크기를 설정해야 함

최소/최대 커넥션 수 설정을 통해 트래픽에 따라 커넥션 개수를 필요한 만큼
유지 가능

\*\* DB 부하가 큰 상황에서 커넥션 개수를 늘리면 오히려 쿼리 실행 시간이
증가될 수 있음

### 커넥션 대기 시간

풀에 사용할 수 있는 커넥션이 없을 때 대기할 수 있는 최대 시간 (보통
0.5초 \~ 3초 이내 설정)

-   커넥션 대기 시간 (Connection Timeout): 사용 가능한 커넥션이 없을 때
    대기하는 최대 시간

```{=html}
<!-- -->
```
    if) 커넥션 풀 크기 → 10
            쿼리 실행 → 10초
            요청 → 20개
            대기 시간 → 30초
    →   10개의 요청이 대기 상태 → 에러 응답이 없어 대기 중인 사용자가 재시도 → 동시 요청 수 30개

    if) 커넥션 풀 크기 → 10
            쿼리 실행 → 10초
            요청 → 20개
            대기 시간 → 5초
    →   10개의 요청이 대기 상태 → 5초 후 에러 응답을 받음 → 동시 요청 수 10개

대기 시간 동안 사용자가 재요청을 할 시 기존 요청 취소 X 신규로 요청이
들어옴

→ 즉, 에러 응답이 나오지 않아 사용자가 새로고침을 한다면 동시 요청 수가
계속해서 증가

### 커넥션 유지 시간

커넥션이 사용되지 않는 시간이 길어지면 연결 종료

-   유휴 커넥션 타임아웃 (Idle Timeout): 사용되지 않는 커넥션을 풀에서
    제거하기까지의 시간

→ DB 설정 비활성화 유지 시간보다 짧을 시 DB가 연결을 끊기 전 커넥션에서
먼저 제거 가능

-   유효성 검사 (Validation Query): 커넥션이 정상적으로 사용 가능한
    상태인지 확인

→ 커넥션을 가져올 때 유효성을 검사하거나 주기적으로 검사 가능

-   커넥션 최대 수명 (Max Lifetime): 커넥션이 생성된 후 풀에서 유지되는
    최대 시간

→ 커넥션이 유효하더라도 최대 수명이 지나면 풀에서 제거

\*\* 최대 유휴 시간 / 유지 시간 무한대로 설정 지양

## 캐시

동일한 데이터를 요청할 때 DB가 아닌 캐시에서 데이터를 읽어와 응답 (자주
조회되는 데이터 저장 적합)

### 적중률

캐시가 얼마나 효율적으로 사용되는 지 판단

    캐시에 존재하는 데이터의 개수 / 캐시에서 조회를 시도한 횟수

적중률이 높을 수록 DB 연동 감소, 응답 시간 감소, DB 부하 감소로 이어짐

하지만 캐시 메모리 용량에는 한계가 있기 때문에 기존 데이터들을 제거해야
함

**캐시 삭제 규칙**

-   Least Recently Used: 가장 오래전 사용된 데이터 제거
-   Least Frequently Used: 가장 적게 사용된 데이터 유지
-   First In First Out: 가장 먼저 들어온 데이터 제거

### 로컬 캐시 vs 리모트 캐시

**로컬 캐시**

장점 - 속도가 빠름 (서버 프로세스와 동일한 메모리를 사용하기 때문에)

단점 - 데이터 크기에 제한, 서버 프로세스 재시작 시 캐시 삭제

**리모트 캐시**

장점 - 캐시 크기 확장 가능, 서버 프로세스가 재시작 되더라도 캐시 유지

단점 - 속도가 느림 (네트워크 통신이 필요하기 때문에 로컬에 비해
상대적으로 느림)

\*\* 데이터 규모가 작고 변경 빈도가 잦다면 로컬 캐시 적합

\*\* 데이터 규모가 크고 배포 빈도가 잦다면 리모트 캐시 적합

**사전 적재**

트래픽이 특정 순간에 급증하는 패턴을 보인다면 미리 캐시에 저장하는 방향
고려 필요

    if) 사용자가 500만 명인 앱에서 특정 쿠폰 발급 → 당일 10%의 사용자가 접속해도 트래픽 100만
    → 미리 500만개의 데이터를 캐시에 저장해두면 당일 10%의 사용자가 접속해도 적중률 99% 이상 유지 가능

**캐시 무효화**

유효하지 않는 데이터를 적절한 시점에 캐시에서 삭제하는 것

-   민감한 데이터 → 원본 데이터 변경시 즉시 캐시 무효화, 리모트 캐시
    저장 (다른 서버 로컬 캐시 변경 X)
-   일반 데이터 → 유효시간을 설정해 주기적으로 갱신

**가비지 컬렉터 / 메모리 사용**

사용하지 않는 메모리를 찾아 반환 → 자바의 경우 가비지 컬렉터가 실행되는
동안 모든 실행 일시 중단

\*\* 메모리 사용량과 GC 시간은 비례 (실제 메모리 사용 패턴에 맞게 최대
힙 크기 조절)

대량 객체 생성 시 메모리 부족 상태 지속 → 데이터 개수 / 조회 범위를
트래픽 규모와 메모리 크기에 맞춰 제한

\*\* 파일 다운로드와 같은 기능 구현 시 스트림을 사용하면 한 번에 읽는
것에 비해 메모리 절약 가능
